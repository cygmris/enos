from org.jgrapht.alg import DijkstraShortestPath
from net.es.enos.api import TopologyFactory

#
# Created by davidhua on 6/10/14.
#

offset = 23 # Remove "urn:ogf:network:es.net:" from router address
endingString = "@es.net" # Append address with @es.net
nodeCounter = 0
lengthCounter = 0
Nonetypecounter = 0
goodpaths = 0
node_dict = {} # Store the path hop where the paths begin to diverge
completedList = {} # Stores paths already computed
nonetype = {}
problem_dict = {}
arrow = " -> " # Arrow for output data. Replace with single space for easy copying into path.py prompt.

# Copied over from path.py-- initializes and fetches topology and list of nodes
topology = TopologyFactory.instance()
topo = topology.retrieveTopologyProvider("localLayer2")
graph = topo.retrieveTopology()
nodes = topo.getNodes()
nodesByLink = topo.getNodesByLink()

# Run loop through every node pair in network
for destNode in nodes:
    destNodeString = str(destNode) # Convert node into string
    destNodeString = destNodeString[offset:]
    destNodeString = destNodeString + endingString # Chop off offset and insert ending string for graph operations
    destNodeGraph = topo.getNode(destNodeString)

    for ordNode in nodes:
        # If origin node and destination node are the same, skip.
        if ordNode == destNode:
            continue
        reversePath = [] # Reverse the hops taken by the reverse route
        orgpath = [] # Store shortest path info in an array
        destpath = [] # Store shortest path info in an array

        ordNodeString = str(ordNode)
        ordNodeString = ordNodeString[offset:]
        ordNodeString = ordNodeString + endingString
        ordNodeGraph = topo.getNode(ordNodeString)

        # Don't repeat paths that have already been run
        completed = destNodeString + arrow + ordNodeString
        if completedList.has_key(completed):
            continue
        completedList[completed.encode("ascii")] = completedList.get(completed, 1)

        completed = ordNodeString + arrow + destNodeString
        if completedList.has_key(completed):
            continue
        completedList[completed.encode("ascii")] = completedList.get(completed, 1)

        # Compute paths forwards and backwards
        firstpath = DijkstraShortestPath.findPathBetween(graph, ordNodeGraph, destNodeGraph)
        secondpath = DijkstraShortestPath.findPathBetween(graph, destNodeGraph, ordNodeGraph)

        # Skip paths that give us a NoneType, but record into nonetype dictionary and increment counter
        if firstpath == None:
            Nonetypecounter += 1
            # Create entry if not in dictionary, else increment value
            nonetype[ordNodeString.encode("ascii")] = nonetype.get(ordNodeString, 1) + 1
            nonetype[destNodeString.encode("ascii")] = nonetype.get(destNodeString, 1) + 1
            continue;
        if secondpath == None:
            nonetype[ordNodeString.encode("ascii")] = nonetype.get(ordNodeString, 1) + 1
            nonetype[destNodeString.encode("ascii")] = nonetype.get(destNodeString, 1) +1
            Nonetypecounter += 1
            continue;

        # Ignore hops within the same location to different routers-- not sure if we want this /
        # since going through different routers means a different path is taken, which is undesirable (@bmah)
        duplicateLink  = '' # Store the previous node in hop
        for link in firstpath:
            if link == duplicateLink:
                continue
            # Remove everything in router address except location (ex lbl)
            # Remove ".split("-"[0]" to remove everything in router address except location-routerName (ex lbl-mr2)
            orgpath.append((nodesByLink.get(link))[0].getId()[23:].split("-")[0])
            duplicateLink = link

        duplicateLink = '' # Reset duplicate field

        for link in secondpath:
            if link == duplicateLink:
                continue
            destpath.append((nodesByLink.get(link))[0].getId()[23:].split("-")[0])
            duplicateLink = link


        # Following lines necessary for path comparison
        orgpath.pop(0)
        destpath.pop(0)

        # Reverse the second path to try to match with the first path
        for index, ignore in reversed(list(enumerate(destpath))):
            reversePath.append(destpath[index])

            #Debugging code, make sure nothing important was chopped off
            #print "source"
            #for path in reversePath:
            #print path
            #print ""
            #print "dest"
            #for path in orgpath:
            #print path


        # Check to see if lengths of paths are the same
        if len(reversePath) != len(orgpath):
            print "path " + ordNodeString + arrow + destNodeString +  " appears to be asymmetrical (lengths differ)"

            #Find out which path is shorter
            length = min(len(reversePath), len(orgpath))
            for i in range(0, length-1):
                # If the two paths differ before the lengths differ, then log where they start to differ
                if orgpath[i] != reversePath[i]:
                    # Store the last node where they were the same into the dictionary
                    problem_dict[orgpath[i-1].encode("ascii")] = problem_dict.get(orgpath[i-1], 1) + 1

                    # Store the hop where the paths begin to differ
                    route = str(orgpath[i-1])+ arrow + str(orgpath[i])
                    node_dict[route.encode("ascii")] = node_dict.get(route, 1) + 1
                    route = str(reversePath[i-1])+ arrow + str(reversePath[i])
                    node_dict[route.encode("ascii")] = node_dict.get(route, 1) + 1
                    break

            # Don't know how to best log nodes if they are the same until one reaches the destination and the other path hasn't
            # Currently stores the last node where the two paths were the same and the node immediately after
            # Also stores the last node where they are the same
            if len(reversePath) < len(orgpath):
                problem_dict[reversePath[len(reversePath)-1].encode("ascii")] = problem_dict.get(reversePath[len(reversePath)-1], 1) + 1

                route = str(orgpath[len(reversePath)-1])+ arrow + str(orgpath[len(reversePath)])
                node_dict[route.encode("ascii")] = node_dict.get(route, 1) + 1
            else:
                problem_dict[reversePath[len(orgpath)-1].encode("ascii")] = problem_dict.get(reversePath[len(orgpath)-1], 1) + 1

                route = str(reversePath[len(orgpath)-1])+ arrow + str(reversePath[len(orgpath)])
                node_dict[route.encode("ascii")] = node_dict.get(route, 1) + 1

            lengthCounter += 1 # Increment length counter
            continue


        # If lengths are the same, check to see if the paths take the same route
        for i in range(len(orgpath)-1):
            if orgpath[i] != reversePath[i]:
                # Store the last node where they are the same
                problem_dict[reversePath[i-1].encode("ascii")] = problem_dict.get(reversePath[i-1], 1) + 1

                # If paths are not the same, store the hop where they begin to differ
                route = str(orgpath[i-1])+ arrow + str(orgpath[i])
                node_dict[route.encode("ascii")] = node_dict.get(route, 1) + 1

                route = str(reversePath[i-1])+ arrow + str(reversePath[i])
                node_dict[route.encode("ascii")] = node_dict.get(route, 1) + 1

                print "path " + ordNodeString + arrow + destNodeString +  " appears to be asymmetrical"
                nodeCounter += 1 # Increment node counter
                break
        goodpaths += 1


# Output info, comment out anything that you don't need

print ""
# Outputs numerical results
print "Numerical results:"
print ("Asymmetric paths counter: " , nodeCounter)
print ("Mismatched length counter: " , lengthCounter)
print ("Nonetype counter: " , Nonetypecounter)
print ("Symmetric paths counter: " , goodpaths)

print ""
print "Problem hops:"
#Output mismatched paths, sorted alphabetical
for key, value in sorted(node_dict.iteritems()):
    print (key, value)


print ""
print "Problem nodes:"
# Output node where problems began, sorted reverse numerical by number of problems at that router
for key, value in sorted(problem_dict.iteritems(), key=lambda (k,v): (v,k)):
    print (key, value)

print ""
print "Nonetype: "
# Outputs which routers are causing Nonetype issues, sorted reverse numerical
for key, value in sorted(nonetype.iteritems(), key=lambda (k,v): (v,k)):
    print (key, value)
